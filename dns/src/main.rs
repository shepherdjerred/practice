use packed_struct::prelude::*;

fn main() {
    println!("Hello, world!");
}

#[derive(PackedStruct)]
#[packed_struct(endian="msb")]
struct Message {
    #[packed_field()]
    header: Header,
    #[packed_field()]
    question: Question,
    authority: i32,
    additional: i32,
}

#[derive(PackedStruct)]
#[packed_struct(endian="msb")]
struct Header {
    // generated by the program creating a query
    #[packed_field(size_bits="16")]
    id: Integer<u8, packed_bits::Bits::<16>>,
    // specifies whether this is a query or a response
    #[packed_field(size_bits="1")]
    qr: Integer<u32, packed_bits::Bits::<1>>,
    // kind of query
    #[packed_field(size_bits="4", ty="enum")]
    opcode: Opcode,
    // whether or not the responding name server is an authority for the question
    #[packed_field(size_bits="1")]
    aa: Integer<u32, packed_bits::Bits::<1>>,
    // whether or not this message was truncated
    #[packed_field(size_bits="1")]
    tc: Integer<u32, packed_bits::Bits::<1>>,
    // whether or not recursion is desired
    #[packed_field(size_bits="1")]
    rd: Integer<u32, packed_bits::Bits::<1>>,
    // whether or not recursion is available
    #[packed_field(size_bits="1")]
    ra: Integer<u32, packed_bits::Bits::<1>>,
    // reserved for future use
    #[packed_field(size_bits="3")]
    z: Integer<u32, packed_bits::Bits::<3>>,
    #[packed_field(size_bits="4", ty="enum")]
    rcode: ResponseCode,
    // number of questions
    #[packed_field(size_bits="16")]
    qdcount: Integer<u32, packed_bits::Bits::<16>>,
    // number of answers
    #[packed_field(size_bits="16")]
    ancount: Integer<u32, packed_bits::Bits::<16>>,
    // number of name server records
    #[packed_field(size_bits="16")]
    nscount: Integer<u32, packed_bits::Bits::<16>>,
    // number of resource records
    #[packed_field(size_bits="16")]
    arcount: Integer<u32, packed_bits::Bits::<16>>,
}

#[derive(PrimitiveEnum_u8, Clone, Copy, Debug, PartialEq)]
enum ResponseCode {
    Ok = 0,
    FormatError = 1,
    ServerFailure = 2,
    NameError = 3,
    NotImplemented = 4,
    Refused = 5,
    // 6-15 are reserved for future use
}

#[derive(PackedStruct)]
#[packed_struct(bit_numbering="msb0")]
struct Question {
    #[packed_field(size_bits="1")]
    qname: Integer<u32, packed_bits::Bits::<1>>,
    qtype: QType,
    class: Class,
}


#[derive(PrimitiveEnum_u8, Clone, Copy, Debug, PartialEq)]
enum Opcode {
    QUERY = 0,
    IQUERY = 1,
    STATUS = 2,
    // 3-15 are reserved for future use
}


#[derive(PrimitiveEnum_u8, Clone, Copy, Debug, PartialEq)]
enum QType {
    A = 1, // host address
    NS = 2, // nameserver
    MD = 3, // obsolete
    MF = 4, // obsolete
    CNAME = 5, // canonical name
    SOA = 6, // start of a zone of authority
    MB = 7, // experimental
    MG = 8, // experimental
    MR = 9, // experimental
    NULL = 10, // experimental
    WKS = 11, // well-known service description
    PTR = 12, // domain-name pointer
    HINFO = 13, // host information
    MINFO = 14, // mailbox information
    MX = 15, // mail exchange
    TXT = 16, // text strings
    // 17-251 are unused
    AXFR = 252, // entire zone records
    MAILB = 253, // mailbox records
    MAILA = 254, // obsolete
    ASTERIX = 255 // all records
}

#[derive(PrimitiveEnum_u8, Clone, Copy, Debug, PartialEq)]
enum Class {
    IN = 1, // internet
    CS = 2, // CSNET, obsolete
    CH = 3, // CHAOS
    HS = 4, // Hesiod
}
